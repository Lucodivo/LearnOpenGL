# Learn OpenGL NOTES

Immediate Mode (fixed function pipeline): Old way of OpenGL, easier but developers have less freedom
Core-Profile Mode: Requires developer to truly understand OpenGL/graphics, but more flexible/efficient

Context: The state of OpenGL
Graphics Pipeline: Process of transforming 3D coordinates => 2D coordinate => colored pixels
OpenGL Shading Language (GLSL): Language shaders are written in
Vertex: Collection of data per 3D coordinate
Vertex Attributes: Any date associated with vertex (ex: 3D position, color value)
Primitives: Hints that tell OpenGL how to render data (ex: points, triangles, line)

== GRAPHICS PIPLINE ==
1. Vertex Shader: 3D coordinates => 3D coordinates & some basic processing on vertex attributes
2. Primitive (Shape) Assembly: Takes all vertices from vertex shader that form a primitive and assembles all the points in the primitive shape given
3. Geometry Shader: Takes in a collection of vertices that form a primitive and has the ability to generate other shapes by emitting new vertices to form new (or other) primitives.
4. Rasterization Stage: Maps the resulting primitives (of Geometry Shader) to the corresponding pixels on the final screen, resulting in fragments for the fragment shader to use.
	- Clipping: Before fragment shaders run, clipping discards all fragments that are outside your view, increasing performance.
5. Fragment Shader: Calculate the final color of a pixel. Usualy the stage where all the advacned OpenGL effects occur (ex: lighting, shadows, color of the light).
6. Alpha Test & Blending: Checks the corresponding depth (and stencil) value of the fragment and uses those to check if the resulting fragment is in front or behind other objects and should be discarded accordingly.
	- NOTE: even if a pixel output color is calculated in the fragment shader, the final pixel color could still be something entirely different when rendering multiple triangles.

Fragment: All the data required for OpenGL to render a single pixel
Shaders: Small programs on the GPU for each step of the graphics pipeline
Normalized Device Coordinates: 3D coordinates in a specific range betweoon [-1.0, +1.0]
Vertex Buffer Objects (VBO): Memory that can store a large number of vertices in the GPU's memory.
    - After binding the buffer using glBindBuffer(), glBufferData() function can be used to store data in VBO
Vertex Array Object (VAO): Memory that can store vertex attribute configurations
    - After bound using glBindVertexArrayS(), any subsequent vertex attribute calls from that point will be stored in VAO
Element Buffer Objects (EBO): A buffer that stores indices that OpenGL uses to decide what vertices to draw
    - The EBO currently bound while a VAO is bound, is stored as the VAO's EBO.

== ECT ==
- The areas of the graphics pipeline that are configureable are the Vertex Shader, Geometry Shader, and Fragment Shader
- In Modern OpenGL we are REQUIRED to define at least a vertex and fragment shader of our own (There are no default vertex/fragment shaders on the GPU)
- Geometry shader is optional and usually left to its default shader
- OpenGL only processes 3D normalized device coordinates, any coordinates outside of the range [-1.0,+1.0] will be clipped/discarded.
- Unlike usual screen coordinates, the pisitive y-axis points in the up direction and (0,0,0) coordinate is in the center.
- A VAO stores the glBindBuffer calls when the target is GL_ELEMENT_ARRAY_BUFFER. 
    - This also means it stores its unbind calls so don't unbind the element array buffer before unbinding your VAO

+++ GLSL +++

### Swizzling:
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;

### Input Variables & Output Variables
Vertex Shaders:
- Receives its input straight from the vertex data (stored using glBindBuffer/glBufferData functions)

Fragment Shaders:
- Requires a vec4 color output variable, since fragment shaders need to generate final output color
    - failing to specify an output color will render your object black (or white)

### Accessing Vector Data
vec4 aVec = vec4(0.1, 0.2, 0.3. 0.4)
aVec.x = aVec.r = aVec.s = 0.1
aVec.y = aVec.g = aVec.t = 0.2
aVec.z = aVec.b = aVec.p = 0.3
aVec.w = aVec.a = aVec.q = 0.4

Uniforms: Global variables that can be accessed from any shader at any stage in the shader program.
    - Whatever the uniform value is set to, it will keep its value until it is reset or update

== ECT ==
- If you declare a uniform that isn't used anywhere in your GLSL coed, the compiler will silently remove the variable from the compiled version
- Finding the uniform location does not require you to use the shader program first 
- Updating a uniform requires you to first use the program (glUseProgram), it sets the uniform on the currently active shader program

++ Matrix Math ++
Transpose: Swap the columns and rows
|a b c|T  |a d g|
|d e f| = |b e h|
|g h i|   |c f i|

Matrix Multiplication
Identity matrix: Multiplying any matrix N by identity matrix will produce the same matrix N.
|1 0 0 0| |X|   |X|
|0 1 0 0| |Y| = |Y|
|0 0 1 0| |Z| = |Z|
|0 0 0 1| |W|   |@|

Scaling matrix:
|1 0 0 0| |X|   |1X|
|0 2 0 0| |Y| = |2Y|
|0 0 3 0| |Z| = |3Z|
|0 0 0 4| |W|   |4W|

Translation matrix:
|1 0 0 1| |X|   |X+1W|
|0 1 0 2| |Y| = |Y+2W|
|0 0 1 3| |Z| = |Z+3W|
|0 0 0 1| |W|   |W   |

Rotations:
- Rotations in 3D are specified with an angle AND a rotaion axis.
Rotation matrix around the X-Axis (where A is the angle:
|1 0    0     0| |X|   |X          |
|0 cosA -sinA 0| |Y| = |YcosA-ZsinA|
|0 sinA cosA  0| |Z| = |YsinA+ZcosA| 
|0 0    0     1| |1| = |1          |

Rotaion matrix aruound the Y-axis
|cosA  0 sinA 0| |X|   |XcosA+ZcosA |
|0     0 0    0| |Y| = |Y           |
|-sinA 0 cosA 0| |Z| = |-XsinA+ZcosA| 
|0     0 0    1| |1| = |1           |

Rotaion matrix aruound the Z-axis
|cosA  -sinA 0 0| |X|   |XcosA-YsinA|
|sinA  cosA  0 0| |Y| = |XsinA+YcosA|
|0     0     0 0| |Z| = |Z          | 
|0     0     0 1| |1| = |1          |